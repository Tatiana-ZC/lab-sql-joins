USE sakila;

-- CHALLENGE: Joining on Multiple Tables

-- 1. List the number of films per category.

-- TABLES TO USE:
-- category: Contains the category_id and name of each film category.
SELECT category_id, name FROM sakila.category;
-- film_category: A junction table to associate films with their respective categories using film_id and category_id.
SELECT film_id, category_id FROM sakila.film_category;
-- film: Contains information about each film, including film_id (which uniquely identifies each film).
SELECT film_id, title FROM sakila.film;

-- STEPS:
-- 1.1 Select the Category Name and Count of Films in each category
-- 1.1.1 Select the Category Name
SELECT name FROM category; 
-- 1.1.2 Count of Films in each category    
SELECT COUNT(film_id), category_id FROM film_category
GROUP BY category_id;

-- 1.2 Join the Tables: Join 3 tables (category, film_category, and film)
SELECT *
FROM 
    category AS c
JOIN 
    film_category AS fc ON c.category_id = fc.category_id
JOIN 
    film AS f ON fc.film_id = f.film_id;

-- 1.3 Group the results by Category: Results by category name in order to count the number of films in each category.
SELECT 
    c.name AS category_name, 
    COUNT(f.film_id) AS number_of_films 
FROM 
    category AS c
JOIN 
    film_category AS fc ON c.category_id = fc.category_id
JOIN 
    film AS f ON fc.film_id = f.film_id
GROUP BY 
    c.name;

-- 2. Retrieve the store ID, city, and country for each store.

-- TABLES TO USE:
-- store: Contains store_id and a reference to address_id.
SELECT store_id, address_id FROM sakila.store;
-- address: Contains address_id, city_id, and detailed address information.
SELECT address_id, city_id, address, district FROM sakila.address;
-- city: Contains city_id, city, and a reference to country_id.
SELECT city_id, city, country_id FROM sakila.city;
-- country: Contains country_id and country names.
SELECT country_id, country FROM sakila.country;

-- STEPS:
-- 2.1 Join the Store Table with the Address Table
-- To get the detailed address information for each store.
SELECT 
    s.store_id, 
    s.address_id, 
    a.address, 
    a.city_id 
FROM 
    store AS s
JOIN 
    address AS a ON s.address_id = a.address_id;

-- 2.2 Add the City Table to the join
-- To get the name of the city for each store.
SELECT 
    s.store_id, 
    a.address, 
    ct.city 
FROM 
    store AS s
JOIN 
    address AS a ON s.address_id = a.address_id
JOIN 
    city AS ct ON a.city_id = ct.city_id;

-- 2.3 Add the Country Table
-- To retrieve the country for each city.
SELECT 
    s.store_id, 
    ct.city, 
    co.country 
FROM 
    store AS s
JOIN 
    address AS a ON s.address_id = a.address_id
JOIN 
    city AS ct ON a.city_id = ct.city_id
JOIN 
    country co ON ct.country_id = co.country_id;

-- 3. Calculate the total revenue generated by each store in dollars.
-- Revenue in this context is likely derived from customer payments for renting movies.

-- TABLES TO USE:
-- store: Contains store_id and references to the staff who work at the store.
SELECT store_id, manager_staff_id FROM sakila.store;
-- staff: Contains staff_id and store_id, linking staff members to stores.
SELECT staff_id, store_id FROM sakila.staff;
-- rental: Contains rental_id, staff_id, and other details about each rental transaction.
SELECT rental_id, staff_id FROM sakila.rental;
-- payment: Contains payment_id, rental_id, amount, and other details about payments made by customers for rentals.
SELECT payment_id, staff_id, rental_id, amount FROM sakila.payment;

-- RELATIONSHIPS: 
-- To calculate the total revenue for each store, let's sum the payment amounts (amount) for all rentals associated with each store.
-- - Staff Members (staff) are associated with a specific Store (store), identified by store_id.
-- - Rentals (rental) are handled by Staff Members (staff), identified by staff_id.
-- - Payments (payment) are made for specific Rentals (rental), identified by rental_id.

-- STEPS:
-- 3.1 Join the Store table with the address table.
-- Ensure the basic relationship between stores and staff is correct: Structure for subsequent joins with the rental and payment tables. 
SELECT 
    s.store_id, 
    st.staff_id 
FROM 
    store AS s
JOIN 
    staff AS st ON s.store_id = st.store_id;
    
-- 3.2 Add the Rental Table
-- Verify that rentals are correctly linked to staff and, by extension, to stores.
-- In order to trace rental transactions back to the store through the staff who handled them.
SELECT 
    s.store_id, 
    r.rental_id 
FROM 
    store AS s
JOIN 
    staff AS st ON s.store_id = st.store_id
JOIN 
    rental AS r ON st.staff_id = r.staff_id;

-- 3.3 Add the Payment Table
-- Retrieve Payment Data: Taking the amount from the payment table, let's visualise the revenue generated from each rental. 
-- This to ensure that the payment amounts are correctly linked to the rentals and thus the stores.
SELECT 
    s.store_id, 
    p.amount 
FROM 
    store AS s
JOIN 
    staff AS st ON s.store_id = st.store_id
JOIN 
    rental AS r ON st.staff_id = r.staff_id
JOIN 
    payment AS p ON r.rental_id = p.rental_id;
    
-- 3.4 Aggregate the Results
-- Aggregate the payment data to calculate the total revenue for each store.
-- Calculate Revenue: The SUM(p.amount) function adds up all the payments associated with rentals processed by the store’s staff.
-- Group Results by Store: Sum up payments by each store (total revenue per store).
SELECT 
    s.store_id, 
    SUM(p.amount) AS total_revenue 
FROM 
    store AS s
JOIN 
    staff AS st ON s.store_id = st.store_id
JOIN 
    rental AS r ON st.staff_id = r.staff_id
JOIN 
    payment AS p ON r.rental_id = p.rental_id
GROUP BY 
    s.store_id;

-- 4. Determine the average running time of films for each category.
-- In order to understand the typical length of films within different categories.
-- Determine characteristics of films within different genres or categories.

-- TABLES TO USE:
-- film: Contains details about each film, including its film_id and length (running time in minutes).
SELECT film_id, length FROM sakila.film;
-- film_category: Links films to their respective categories using film_id and category_id.
SELECT film_id, category_id FROM sakila.film_category;
-- category: Contains the category_id and the name of each category (e.g., Action, Drama).
SELECT category_id, name FROM sakila.category;

-- RELATIONSHIPS: 
-- To calculate the average running time for each category, let's join these three tables together.
-- - Films (film) are associated with one or more Categories (category) through the film_category junction table.
-- - Only included films that have a valid category association. 
-- - The multiple joins allow to group films by category and calculating the average running time.

-- STEPS:
-- 4.1 Join the film table to access the length of each film, and the the film_category table to connect each film with its categories.
-- Films are linked to their categories and it's possible to access the length of each film.
SELECT 
    f.film_id, 
    f.length, 
    fc.category_id 
FROM 
    film AS f
JOIN 
    film_category AS fc ON f.film_id = fc.film_id;

-- 4.2 Join with the category table to retrieve the name of each category.
SELECT 
    f.film_id, 
    f.length, 
    c.name AS category_name 
FROM 
    film AS f
JOIN 
    film_category AS fc ON f.film_id = fc.film_id
JOIN 
    category AS c ON fc.category_id = c.category_id;

-- 4.3 Group the results by category name and calculate the average film length within each category.
-- Add the Aggregation: Using the ROUND and AVG function to running time for films within each category.
SELECT 
    c.name AS category_name, 
    ROUND(AVG(f.length), 2) AS avg_running_time 
FROM 
    film AS f
JOIN 
    film_category AS fc ON f.film_id = fc.film_id
JOIN 
    category AS c ON fc.category_id = c.category_id
GROUP BY 
    c.name;


-- BONUS:

-- 5. Identify the film categories with the longest average running time.
-- Let's calculate the average running time for each category.
-- Then sort the results to find out which categories have the longest films on average.

-- TABLES TO USE:
-- film: Contains details about each film, including film_id and length (running time in minutes).
SELECT film_id, length FROM sakila.film;
-- film_category: Links films to their respective categories using film_id and category_id.
SELECT film_id, category_id FROM sakila.film_category;
-- category: Contains the category_id and the name of each category (e.g., Action, Drama).
SELECT category_id, name FROM sakila.category;

-- RELATIONSHIPS: 
-- Films (film) are associated with one or more Categories (category) through the film_category junction table.
-- - To identify the categories with the longest average running time, let's join these three tables together.
-- - Then, let's sort the results based on the average film length.

-- STEPS:
-- 5.1 Join the film table to access the length of each film, and the film_category table to link each film with its categories.
-- - films are linked to their categories and now it's possible to access the length of each film.
SELECT 
    f.film_id, 
    f.length, 
    fc.category_id 
FROM 
    film AS f
JOIN 
    film_category AS fc ON f.film_id = fc.film_id;

-- 5.2 Join with the category table to retrieve the name of each category.
SELECT 
    f.film_id, 
    f.length, 
    c.name AS category_name 
FROM 
    film AS f
JOIN 
    film_category AS fc ON f.film_id = fc.film_id
JOIN 
    category AS c ON fc.category_id = c.category_id;

-- 5.3 Calculate the average running time for films within each category and sort the results to find the longest.
-- In order to determine which categories tend to have longer films on average.
-- - Group the results by category name to calculate the average film length within each category.
-- - Order the results by average running time in descending order to find the categories with the longest films.
-- -- Sorting by avg_running_time in descending order ensures that the longest average times come first. 
SELECT 
    c.name AS category_name,
    AVG(f.length), 2 AS avg_running_time 
FROM 
    film f
JOIN 
    film_category fc ON f.film_id = fc.film_id
JOIN 
    category c ON fc.category_id = c.category_id
GROUP BY 
    c.name
ORDER BY 
    avg_running_time DESC;

-- 5.4 Limit the result to the top entry to identify the category with the longest average running time.
-- - The LIMIT 1 clause is used to restrict the result to the top category.
-- - To make clear which category has the longest films on average.
SELECT 
    c.name AS category_name, 
    ROUND(AVG(f.length), 2) AS avg_running_time 
FROM 
    film f
JOIN 
    film_category fc ON f.film_id = fc.film_id
JOIN 
    category c ON fc.category_id = c.category_id
GROUP BY 
    c.name
ORDER BY 
    avg_running_time DESC
LIMIT 1;

-- 6. Display the top 10 most frequently rented movies in descending order.
-- Let's identify the most frequently rented movies, sorted by the 10 top in descending order (of their rental frequency).
-- Let's identify Which movies are the most popular among customers. 

-- TABLES TO USE:
-- film: Contains details about each film, including film_id and title.
SELECT film_id, title, rental_duration FROM sakila.film;
-- inventory: Contains information about the physical copies of each film (inventory_id), including which films (film_id) are available for rent.
SELECT inventory_id, film_id FROM sakila.inventory;
-- rental: Contains details about each rental transaction, including rental_id, inventory_id, and the date the rental took place.
SELECT rental_id, inventory_id, rental_date FROM sakila.rental;

-- RELATIONSHIPS: 
-- Films (film) are associated with Inventory Items (inventory) through film_id. 
-- Each inventory item represents a copy of a film that can be rented.
-- Rentals (rental) are associated with Inventory Items (inventory) through inventory_id. 
-- Each rental transaction corresponds to an inventory item being rented out.

-- STEPS:
-- 6.1 Join the film table to access the titles of the films, and the the inventory table to link each film with its available inventory items.
-- - films are linked to their inventory items, ensuring that each film has corresponding copies available for rent.
SELECT 
    f.film_id, 
    f.title, 
    i.inventory_id 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id;

-- 6.2 Join with the rental table to connect the inventory items to their rental records.
-- - With the joins it is possible to trace rental transactions back to the films they correspond to.
-- - Retrieve the rental records associated with each film, verifying that each rental is linked back to the correct film title.
SELECT 
    f.film_id, 
    f.title, 
    r.rental_id 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
JOIN 
    rental AS r ON i.inventory_id = r.inventory_id;

-- 6.3 Group the results by film title to count the number of rentals for each film.
-- - The 'Gorup by' allows to calculate how many times each film has been rented. 
-- - The aggregation using COUNT allows to summarize this data in a meaningful way.
SELECT 
    f.title, 
    COUNT(r.rental_id) AS rental_count 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
JOIN 
    rental AS r ON i.inventory_id = r.inventory_id
GROUP BY 
    f.title;

-- 6.4 Sort (order) the films by rental count in descending order to list the most frequently rented films first.
SELECT 
    f.title, 
    COUNT(r.rental_id) AS rental_count 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
JOIN 
    rental AS r ON i.inventory_id = r.inventory_id
GROUP BY 
    f.title
ORDER BY 
    rental_count DESC;

-- 6.5 Limit the result to the top 10 to identify the top 10 most rented films.
SELECT 
    f.title, 
    COUNT(r.rental_id) AS rental_count 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
JOIN 
    rental AS r ON i.inventory_id = r.inventory_id
GROUP BY 
    f.title
ORDER BY 
    rental_count DESC
LIMIT 10;

-- 7. Determine if "Academy Dinosaur" can be rented from Store 1.
-- To check whether the movie titled "Academy Dinosaur" is available for rent at Store 1. 
-- Let's verify if there is an inventory item for "Academy Dinosaur" that belongs to Store 1.
-- Checking the availability of a specific film in a specific store.

-- TABLES TO USE:
-- film: Contains details about each film, including film_id and title.
SELECT film_id, title FROM sakila.film;
-- inventory: Contains information about the physical copies of each film (inventory_id), including the store_id where the inventory item is located.
SELECT inventory_id, film_id, store_id FROM sakila.inventory;

-- RELATIONSHIPS: 
-- Films (film) are associated with Inventory Items (inventory) through film_id.
-- Inventory Items (inventory) are associated with a specific Store (store) through store_id.
-- To determine if "Academy Dinosaur" is available at Store 1, let's:
-- - Identify the film_id for "Academy Dinosaur".
-- - Check if there are any inventory items for this film_id located in Store 1.

-- STEPS:
-- 7.1 Verify Film-Inventory Relationship: Ensure that "Academy Dinosaur" has associated inventory items in the inventory table. 
-- Join the film table with the inventory table using film_id to identify the film_id for "Academy Dinosaur".
-- - This way, there is a connection for the film "Academy Dinosaur" to its physical copies available for rent (link to its inventory items).
-- - Check for Inventory Existence: Confirm that there are inventory items available for this film (this to determine general availability).
SELECT 
    f.film_id, 
    f.title, 
    i.inventory_id 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
WHERE 
    f.title = 'Academy Dinosaur';

-- 7.2 Add the Store-Specific Availability: With the WHERE clause let's check if the inventory items are specifically located in the store of interest. 
-- - Filter by Store: The condition ensures is only looking at the specific film ("Academy Dinosaur") at the specific store (Store 1).
-- - Verify Specific Availability: Confirm that inventory items for "Academy Dinosaur" exist specifically in Store 1.
SELECT 
    f.title, 
    i.inventory_id, 
    i.store_id 
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
WHERE 
    f.title = 'Academy Dinosaur'
    AND i.store_id = 1;

-- 7.3 Add the Conditional Logic: Use a CASE statement to determine and return the availability status of "Academy Dinosaur" in Store 1.
-- To define whether "Academy Dinosaur" is available at Store 1 based on the existence of matching inventory items.
-- - Conditional Logic: The CASE expression provides a clear, user-friendly output (either "Available" or "NOT Available") based on the inventory status.
SELECT 
    CASE 
        WHEN COUNT(i.inventory_id) > 0 THEN 'Available'
        ELSE 'NOT Available'
    END AS availability_status
FROM 
    film AS f
JOIN 
    inventory AS i ON f.film_id = i.film_id
WHERE 
    f.title = 'Academy Dinosaur'
    AND i.store_id = 1;

-- 8. Provide a list of all distinct film titles, along with their availability status in the inventory step by step.
-- Include a column indicating whether each title is 'Available' or 'NOT available'. 
-- - Note that there are 42 titles that are not in the inventory, and this information can be obtained using a CASE statement combined with IFNULL.
-- Let's list all distinct film titles along with a status indicating whether each title is currently 'Available' or 'NOT Available'. 
-- - Then, let's define that the status should be based on whether any copies of the film exist in the inventory.

-- TABLES TO USE:
-- film: Contains details about each film, including film_id and title.
SELECT film_id, title FROM sakila.film;
-- inventory: Contains information about the physical copies of each film (inventory_id), including the film_id to which they belong.
SELECT inventory_id, film_id, store_id FROM sakila.inventory;

-- RELATIONSHIPS: 
-- Films (film) are associated with Inventory Items (inventory) through film_id.
-- If there are inventory items for a film, it means the film is available; if not, it is marked as 'NOT Available'.
-- In order to determine the availability status for each film:
-- - Let's check if there are any inventory items associated with each film.
-- - If there are, the film is 'Available'; if there aren’t, it’s 'NOT Available'.

-- STEPS:
-- 8.1 Left Join the film table with with inventory, to determine if there are any inventory items associated with each film.
-- - Link each film title to its inventory items, using title from the film table allows to have the distinct film titles in the output.
-- - Titles without inventory items are still included in the results, as titles with no inventory items for a film, will appears in the results with a 'NOT Available' status.
SELECT 
    f.title, 
    i.inventory_id 
FROM 
    film AS f
LEFT JOIN 
    inventory AS i ON f.film_id = i.film_id;

-- 8.2 Add the Conditional Logic: 
-- The CASE statement is to determine the availability status for each film.
-- - The CASE expression provides a clear, user-friendly status for each film's availability based on the presence of inventory items.
-- The count of inventory items and the availability status are calculated for each distinct film title.
-- - COUNT(i.inventory_id) > 0 evaluates whether there are any inventory items associated with the film.
-- - If the count is greater than 0, the status is 'Available'. If there are no inventory items (the count is 0), the status is 'NOT Available'.
-- The GROUP BY clause aggregate the results by film title, so it's possible to calculate the availability status for each distinct film title.
-- - This result is aliased as availability_status.
SELECT 
    f.title, 
    CASE 
        WHEN COUNT(i.inventory_id) > 0 THEN 'Available'
        ELSE 'NOT Available'
    END AS availability_status
FROM 
    film AS f
LEFT JOIN 
    inventory AS i ON f.film_id = i.film_id
GROUP BY 
    f.title;

-- 8.3 Sort the results by film title to display results in a alphabetically list.
-- - The ORDER BY clause sorts the results alphabetically by film title.
-- - Sorting in ascending order makes the list easy to read and easy to navigate.
SELECT 
    f.title, 
    CASE 
        WHEN COUNT(i.inventory_id) > 0 THEN 'Available'
        ELSE 'NOT Available'
    END AS availability_status
FROM 
    film AS f
LEFT JOIN 
    inventory AS i ON f.film_id = i.film_id
GROUP BY 
    f.title
ORDER BY 
    f.title ASC;
